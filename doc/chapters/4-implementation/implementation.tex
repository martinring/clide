\chapter{Implementierung}
\label{sec:imp}

Im folgenden werden einige interessante Gesichtspunkte der Implementierung, die in Kapitel
\ref{sec:draft} nur kurz angerissen wurden, genauer herausgearbeitet.

\section{Abstraktion vom Protokoll}
\label{sec:jsc}

Um das Protokoll austauschbar zu gestalten wurde eine Abstraktion über WebSockets implementiert.
Hierfür wurde auf der Browserseite der \texttt{ScalaConnector} und auf Seiten des Servers der
\texttt{JSConnector} entwickelt.

\subsection{ScalaConnector}

Das \texttt{ScalaConnector} wurde in CoffeeScript als RequireJS-Modul implementiert und dient zur
Kommunikation mit dem Webserver. Ein beliebiges Objekt kann sich über den ScalaConnector mit dem
Server verbinden, sodass dieser dann direkt die Funktionen dieses Objekts aufrufen kann.

\begin{lstlisting}
define -> class ScalaConnector
  constructor: (@url,@object,init) -> ...
\end{lstlisting}

Dem Konstruktor wird zum einen die url (\texttt{url}) des Websockets mit dem verbunden werden soll,
zum anderen das Objekt (\texttt{object}), welches dem Server als Schnittstelle zur verfügung
gestellt werden soll übergeben. Als optionales Argument kann eine \texttt{init}-Funktion übergeben
werden, welche aufgerufen wird, sobald die Verbindung hergestellt worden ist.

Intern wird im Konstruktor zunächst eine Verbindung aufgebaut und an das
\texttt{onmessage}-Callback des Websockets verbunden:

\begin{lstlisting}
@socket = new WebSocket(@url) # Connect to server
@socket.onmessage = (e) =>    
  @bytesDown += e.data.length # Downstream traffic measure
  recieve(JSON.parse(e.data)) # Interpret messages as JSON
\end{lstlisting}

Die \texttt{recieve}-Funktion unterscheidet hierbei zwischen Antworten auf eigene Anfragen und
Anfragen bzw. Kommandos vom Server:

\begin{lstlisting}
recieve = (e) =>  
  if e.action # if an action is defined this is a command from the server
    f = @object[e.action] # we try to find the action on the connected object
    if f?
      result = f.apply(f,e.args) or null # execute the function and save the result
      # if an id for the message is defined the server awaits an answer with the result of the
      # function execution. otherwise this is just a command (or server-push)
      if e.id then @socket.send JSON.stringify 
        resultFor: e.id
        success: true
        data: result
    else # if the action does not exist we send an error message to the server
      if e.id then @socket.send JSON.stringify
        resultFor: e.id
        success: false
        message: "action '#{e.action}' does not exist"
      else console.error "action '#{e.action}' does not exist"
  else # if no action is defined the message must be an answer to a request
    callback = @results[e.resultFor] # retrieve the callback function for this action
    if callback 
      callback(e.data) # answer the callback
      @results[e.resultFor] = null # delete the callback function
\end{lstlisting}

Hierbei werden 3 verschiedene Fälle unterschieden:

\begin{itemize}  
  \item Die Nachricht enthält das Feld \texttt{action}: Es handelt sich um eine
Anfrage oder ein Kommando vom Server.
  \begin{itemize}
    \item Wenn zusätzlich das Feld \texttt{id} definiert ist, erwartet der Server eine Antwort mit 
    dieser id als Referenz, es handelt sich also um eine Abfrage.
    \item Wenn das Feld nicht enthalten ist, handelt es sich um eine einfache Nachricht vom Server
    auf die nicht geantwortet wird.
  \end{itemize}
  \item Wenn die Nachricht das Feld \texttt{action} nicht enthält, handelt es sich um eine Antwort 
  auf eine vorherige Anfrage des Clients. In diesem Fall wird die entsprechende Callbackfunktion mit
  dem Ergebnis des Servers aufgerufen.
\end{itemize}

Der Vorteil der Repräsentation über fehlende Felder ist die Kompaktheit der Daten. Da der WebSocket
konfiguriert ist, die Daten zusätzlich komprimiert zu übertragen, sind die Nachrichten sehr klein.
Noch kleiner können sie gemacht werden indem ein eigenes Protokoll implementiert wird. Diese
Abstrakte Implementierung erlaubt das sehr leicht, da nur an zwei Stellen etwas ausgetauscht werden
muss.

Das Gegenstück ist natürlich das Versenden von Daten. Antworten auf Serveranfragen, werden wie oben
beschrieben automatisch verschickt. Anfragen können über die \texttt{call}-Funktion versendet
werden.

\begin{lstlisting}      
    call: (options) =>      
      if options and options.action        
        if options.callback
          @results[@id] = options.callback
          options.id = @id
          @id += 1
        @socket.send JSON.stringify(options)
      else
        console.error 'no action defined'
\end{lstlisting}

Die Funktion erwartet ähnlich wie die \texttt{ajax}-Funktion aus jQuery ein Konfigurationsobjekt
\texttt{options}, in welchem mindestens das Feld \texttt{action} definiert sein muss. (Andernfalls
wird ein Fehler geworfen) Darüber wird definiert welche Funktion auf dem Server aufgerufen werden
soll.

Wenn zusätzlich das feld \texttt{callback} mit einer Callback-Funktion belegt wird, wird eine
\texttt{id} generiert, welche dem Server gesendet wird um unter dieser \texttt{id} zu antworten.
(Siehe oben) Das gesammte Objekt wird nun (natürlich ohne die Callbackfunktion) an den Server als
JSON übertragen. Wenn keine Callbackfunktion definiert wurde, wird auch keine Antwort vom Server
gesendet.

\subsection{JSConnector}

Das Gegenstück zum \texttt{ScalaConnector} auf der Serverseite ist der \texttt{JSConnector}. Dieser
wurde mit Hilfe dynamischer Typisierung verwirklicht. (Zu finden unter \texttt{/app/js/JSConnector})

Für die Kommunikation Verwenden wir die Akka-Iteratees und Enumerators (Siehe auch Abschnitt
\ref{sec:iteratees}). Iteratees für den Eingehenden Datenstrom über den Websocket und Enumerator für
die zu sendenden Daten verwendet. Da wir hier ein imperatives Modell entwickeln wollen, können wir
zur Erzeugung des Enumeratee auf die \texttt{Concurrent.broadcast}-Funktion aus der Play API
zurückgreifen.

\begin{lstlisting}
trait JSConnector {
  val (out, channel) = Concurrent.broadcast[JsValue]
  val in = Iteratee.foreach[JsValue] { json =>
    ...
\end{lstlisting}

Über den \texttt{channel} ist es später möglich Nachrichten an den Client zu senden (Welcher per
WebSocket an den Enumeratee \texttt{out} verbunden ist). Der eigentliche Knackpunkt sind jedoch wie
beim Client das Empfangen sowie das Versenden von Nachrichten.

Beim Empfang wird genau wie auf der Browserseite zwischen den 3 beschriebenen Fällen unterschieden:

\begin{lstlisting}
  val in = Iteratee.foreach[JsValue] { json =>    
    (json \ "action").asOpt[String] match {
      case Some(a) => // an action is defined    
        require(actions.isDefinedAt(a))
        scala.concurrent.future(actions(a)(json \ "data")).onComplete {
          case Success(result) =>
            (json \ "id").asOpt[Long].map(id => channel.push(JsObject(
                "resultFor" -> JsNumber(id) ::
                "data" -> js.convert(result) ::
                Nil)))
          case Failure(msg) =>
            debug(msg)
        }
      case None => (json \ "resultFor").asOpt[Long] match {
        case Some(id) =>          
          val p: Promise[JsValue] = js.requests(id)
          if (!(json \ "success").as[Boolean])
            p.failure(new Exception((json \ "message").as[String]))
          else
            p.complete(Try(json \ "data"))
          js.requests.remove(id)
        case None =>
      }
    }
  }.mapDone(_ => onClose)
\end{lstlisting}

Um die Ausführung nicht zu blockieren verwenden wir \textit{Futures} (Abschnitt \ref{sec:futures}),
die Anfragen des Clients in eigenen Threads ausführen. Wenn der Client eine Anfrage stellt wird der
enstprechenden Funktion das Datenobjekt aus dem Empfangenen JSON-Code übergeben und diese in einem
Future ausgeführt. Wenn das Future die Ausführung erfolgreich beendet wird das Ergebnis im
Bedarfsfall (\texttt{id} ist in der Anfrage definiert) an den Client zurückgesandt. Im Fehlerfall
wird das Ereignis geloggt. Da Fehlerfälle für den Client uninteressant sind, da das debugging auf
dem Server Stattfinden sollte werden sie in diese Richtung nicht übertragen. Wenn signalisiert
werden soll, dass eine Aktion aus einem Bestimmten Grund nicht ausgeführt werden kann sollte mit
einem geeigneten Datentyp ein Wohldefiniertes Ergebnis von der entprechenden Funktion zurückgegeben
werden. (z.B: \texttt{Option[T]})

Zu beachten ist, dass für ein erfolgreiches Versenden das Funktionsergebnis einen Typ haben muss,
welcher die Typklasse \texttt{json.Writes} implementiert, damit die Daten konvertiert werden können.
Ist dies nicht der Fall kann der Code nicht übersetzt werden, da ein Typfehler vorliegt.

Für die Kommunikation nach \glqq unten\grqq nutzen wir dynamische Typisierung. In einer Klasse die
den \texttt{JsConnector} einmischt werden drei Objekte zur Verfügung gestellt:

\begin{itemize}
  \item \texttt{js.ignore} kann verwendet werden um Kommandos oder Informationen an den Client zu 
  senden, ohne dass eine Antwort erwartet wird.
  \item Über \texttt{js.async} können Anfragen versendet werden, für welche man ein Future erhält, 
  welches bei Erhalt der Nachricht erfüllt wird.
  \item In manchen Fällen kann es notwendig sein, innerhalb eines Threads zu blockieren, bis die 
  Antwort vom Browser erhalten wurde, dafür kann \texttt{js.sync} verwendet werden.
\end{itemize}

Der Aufruf \texttt{js.async.moveCursor(4,1)} Würde beispielsweise dazu führen, dass folgendes JSON
Objekt an den Browser gesandt wird:

\begin{lstlisting}
{
  action: "moveCursor",
  id: 12803,
  data: [4,1]
}
\end{lstlisting}

Auf dem Client würde dadurch die Funktion \texttt{moveCursor} mit den beiden Argumenten \texttt{4}
und \texttt{1} aufgerufen und das Ergebnis mit der Referenz-id 12803 zurück an den Server gesendet,
wo dann das Future mit dem Funktionsergebnis erfüllt würde.

Am Beispiel des \texttt{async}-Objekts wollen wir die Funktionsweise der Objekte Kurz illustrieren.
Es werden die drei Funktionen \texttt{selectDynamic}, \texttt{applyDynamic} sowie
\texttt{applyDynamicNamed} implementiert, sodass Aufrufe der Form \texttt{js.async.foo},
\texttt{js.async.foo(1, bar)} sowie \texttt{js.async.foo(bar = 3, doo = 5)} möglich sind. (Siehe
Abschnitt \ref{sec:dyn})

\begin{lstlisting}
    object async extends Dynamic {
      def selectDynamic(action: String): Future[JsValue] =
        applyDynamicNamed(action)()

      def applyDynamicNamed(action: String)(args: (String, Any)*): Future[JsValue] = {
        channel.push(JsObject(
          "action" -> JsString(action) ::
            "id" -> JsNumber(id) ::
            "args" -> JsArray(JsObject(args.map { case (n, a) => (n, convert(a)) }) :: Nil) ::
            Nil
        ))
        val result = Promise[JsValue]()
        requests(id) = result
        id += 1
        result.future
      }

      def applyDynamic(action: String)(args: Any*): Future[JsValue] = {
        channel.push(JsObject(
          "action" -> JsString(action) ::
            "id" -> JsNumber(id) ::
            "args" -> JsArray(args map convert) ::
            Nil
        ))
        val result = Promise[JsValue]()
        requests(id) = result
        id += 1
        result.future
      }
    }
\end{lstlisting}

\clearpage

\section{Synchrone Repräsentation von Dokumenten}

Bla bla

\section{Clientseitiges Syntaxhighlighting}
\label{sec:syntax}

Auf Grund der in Kapitel \ref{sec:draft} beschriebenen Notwendigkeit, Verbindungskapazität
einzusparen musste ein Teil des Syntaxhighlightings, welches von Isabelle/Scala betrieben wird auf
Browserseite nachgebildet werden. Dafür wurde ein CodeMirror-\texttt{Mode} in CoffeeScript
implementiert. (Zu finden unter \texttt{/app/assets/javascripts/mode/isabelle.coffee})

Dafür wurde die glücklicherweise in \cite{isabelle} detailliert beschriebene äußere Syntax einfach
in reguläre Ausdrücke übersetzt. Die Möglichkeit der Stringinterpolation in CoffeeScript hat sich
hierbei als Hilfreich heausgestellt:

\begin{lstlisting}
  # extracted from the isabelle reference manual
  greek       = "(?:\\\\<(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|' +
    'mu|nu|xi|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|' +
    'Pi|Sigma|Upsilon|Phi|Psi|Omega)>)"
  digit       = "[0-9]"
  latin       = "[a-zA-Z]"
  sym         = "[\\!|\\#|\\$|\\%|\\&|\\*|\\+|\\-|\\/|\\<|\\=|\\>|\\?|\\@|\\^|\\_|\\||\\~]"
  letter      = "(?:#{latin}|\\\\<#{latin}{1,2}>|#{greek}|\\\\<^isu[bp]>)"
  quasiletter = "(?:#{letter}|#{digit}|\\_|\\')"
  ident       = "(?:#{letter}#{quasiletter}*)"
  longident   = "(?:#{ident}(?:\\.#{ident})+)"
  symident    = "(?:#{sym}+|\\\\<#{ident}>)"
  nat         = "(?:#{digit}+)"
  floating    = "-?#{nat}\\.#{nat}"  
  variable    = "\\?#{ident}(?:\\.#{nat})?"
  typefree    = "'#{ident}"
  typevar     = "\\?#{typefree}(?:\\.#{nat})"
  string      = "\\\".*\\\""
  altstring   = "`.*`"
  verbatim    = "{\\*.*\\*}"  
  abbrev =
    '\\<\\.|\\.\\>|\\(\\||\\|\\)|\\[\\||\\|\\]|\\{\\.|\\.\\}|\\/\\\\|\\\\\\/' +
    '|\\~\\:|\\(\\=|\\=\\)|\\[\\=|\\=\\]|\\+o|\\+O|\\*o|\\*O|\\.o|\\.O' +
    '|\\-o|\\/o|\\=\\_\\(|\\=\\_\\)|\\=\\^\\(|\\=\\^\\)|\\-\\.|\\.\\.\\.|(?:Int|Inter' +
    "|Un|Union|SUM|PROD)(?!#{quasiletter})"
\end{lstlisting}

Als besonderes schwierig stellte sich die Erkennung von Kontrollsymbolen für die korrekte
Darstellung von Sub- und Superskript bzw. Fettgedruckten Zeichen sowie der Spezialsymbole, welche
als entsprechende LaTeX-Symbole dargestellt werden sollen heraus, da diese an jeder beliebigen
Stelle in der Syntax Vorkommen können und so nicht leicht mit entsprechenden Klassen markiert werden
können. Um dieses Problem zu lösen wird ein Trick angewandt: Es wurden zwei Grammatiken
implementiert, welche den Zeichenstrom zeilenweise simultan verarbeiten. Die Ergebnisse werden dann
kombiniert, sodass für jedes Token jeweils die Vereinigung der Ergebnisse beider Parser
zurückgegeben wird.

Bei der Parsierung werden jeweils nur die sichtbaren Zeilen verarbeitet, deswegen ist es notwendig
am Ende jeder Zeile einen eindeutigen Zustand zurückzugeben mit dem die Verarbeitung der nächsten
Zeile ohne weitere kontextuelle Informationen fortgesetzt werden kann. Da Isabelle wie ML
verschachtelte Kommentare zulässt muss dieser unter anderem auch die Kommentarebene enthalten.

\section{Substitution von Symbolen}

Die im vorherigen Abschnitt beschriebenen Tokenklassen werden verwendet um Symbole direkt im
Quelltext zu substituieren. Da CodeMirror glücklicherweise seit Version 3.0 welche gegen Ende der
Bearbeitungszeit dieser Diplomarbeit veröffentlicht wurde die Möglichkeit bietet Textstellen durch
HTML-Widgets zu ersetzten, konnte eine vorheriger serverseitiger Ansatz, der von Natur aus recht
Fehleranfällig war, da mit den Verschiedenen Positionssystemen von Isabelle und CodeMirror ständig
herumgerechnet werden musste, glücklicherweise verworfen werden.

Die Grundsätzliche Idee bei der Symbol-Substitution ist es, den eigentlich Isabelle-Quelltext auf
Clientseite unverändert zu lassen und nur die Visualisierung anzupassen. Die Substitution findet in
\texttt{/app/assets/javascripts/rjs/editor.coffee} statt.

Hierfür werden beim Laden eines Dokuments zunächst alle Vorkommen von Spezialsymbolen ersetzt. Dafür
bedienen wir uns des CodeMirror Plugins \texttt{SearchCursor}, das es erlaubt den Text mit regulären
Ausdrücken effizient zu durchsuchen.

\begin{lstlisting}
cursor = @cm.getSearchCursor(/\\<(\^?[A-Za-z]+)>/)

while cursor.findNext()
  sym = symbols[cursor.pos.match[0]]
  if sym?
    from = cursor.from()
    to   = cursor.to()
    @cm.markText(from, to, {
      replacedWith: sym(),
      clearOnEnter: false
    })
\end{lstlisting}

Im laufenden Betrieb werden dann bei jeder Veränderung die Tokenklassen an den veränderten
Positionen betrachtet, um zu entscheiden, ob es sich um Spezialsymbole handelt.

Dafür wird das \texttt{onchange}-Callback der CodeMirror Instanz implementiert. Wir verwenden an
dieser Stelle \texttt{.operation} um die gesammte Operation auszuführen, bevor die Visualisierung
angepasst wird, dadurch wird die Ausführungsgeschwindigkeit drastisch erhöht. Zudem gehen wir
sicher, dass keine Selektion vorliegt, da in diesem Fall zunächst keine Ersetzungen Stattfinden
sollen bis die Selektion wieder aufgehoben wurde.

\begin{lstlisting}
@cm.on 'change', (editor,change) => editor.operation => unless editor.somethingSelected()
  ...
\end{lstlisting}

Nun löschen wir alle zuvor eingeführten Substitutionen (durch die Eingabe kann sich das zu
Substitutierende Zeichen verändert haben) Da wir \texttt{CodeMirror.operation} verwenden, ist diese
Aktion relativ performant.

\begin{lstlisting}
pos   = change.to
token = editor.getTokenAt(pos)          
marks = editor.findMarksAt(pos)
mark.clear() if mark.__special for mark in marks 
\end{lstlisting}

Wenn es sich bei dem aktuellen Token nun um ein Spezielles Zeichen handelt, dann wird es mit Hilfe
des CoffeeScript Moduls \texttt{symbols} welches über RequireJS importiert wurde zu einem Widget
übersetzt, welches dann als Textsubstitution eingesetzt werden kann.

\begin{lstlisting}            
    if token.type? and (token.type.match(/special|symbol|control|sub|sup|bold/))
      wid = symbols[token.string]
      if wid?
        @cm.markText from,to,          
          replacedWith: wid(token.type)
          clearOnEnter: false
          __special:    true
\end{lstlisting}

Das \texttt{symbols}-Modul wurde aus der Datei \texttt{/etc/symbols} in der Isabelle Plattform
abgeleitet. Zusätzlich wurden Informationen über den zu verwendenden LaTeX Font (Caligraphic,
Fraktur, AMS, ...) für jedes Symbol manuell eingearbeitet.