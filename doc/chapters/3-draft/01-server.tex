\section{Server}

Der Webserver muss neben den normalen Aufgaben eines Webservers, wie der Bereitstellung der Inhalte,
der Authentifizierung der Benutzer sowie der Persistierung bzw. Bereitstellung der
nutzerspezifischen Daten (In unserem Fall Projekte / Theorien), auch eine besondere Schnittstelle
für die Arbeit mit den Theorien bereitstellen. Vom Browser aus muss es möglich sein,

\begin{itemize}
  \item die einzelnen Theorien in Echtzeit zu bearbeiten,
  \item Informationen über Beweiszustände bzw. Fehler zu erhalten,
  \item als auch Informationen über die Typen, bzw. Definitionen von Ausdrücken zu erhalten.
\end{itemize}

All diese Informationen müssen zuvor Serverseitig aufbereitet und bereitgestellt werden. Dabei ist
es aus Sicht der Perfomanz wichtig, unnötige Informationen zu eliminieren und die Daten zu
komprimieren.

Der Server stellt zum einen eine normale \acr{http} API zur Authentifizierung und zur Verwaltung der
Projekte zur Verfügung, zum andern eine WebSocket Schnittstelle zur Arbeit mit den Theorien. Während
bei der \acr{http} API auf bewährte Methoden aus der Literatur zurückgegriffen werden kann gibt es
für die WebSocket Schnittstelle keine nennenswerten Erfahrungen auf die hier aufgebaut werden
könnte.

\subsection{Wahl des Webframeworks}

Da wir die Isabelle/Scala Schnittstelle nutzen, liegt es nahe ein Webframework in Scala zu nutzen um
den Aufwand für die Integration gering zu halten. Dafür existieren momentan zwei ausgereifte,
bekannte Alternativen:

\begin{itemize}

  \item Das \textit{Lift Webframework}\footnote{http://www.liftweb.org} bietet viele neue Ansätze in
der Webprogrammierung und kann als Experimentierkasten verstanden werden. Für jeden Anwendungsfall
gibt es gleich mehrere Lösungen. Lift wird allerdings auf Grund des Rückzugs von David Pollack aus
der Entwicklung seit einiger Zeit nicht mehr geordnet weiter entwickelt wird und ist zudem für
unsere Zwecke überdimensioniert. Da die Webanwendung eher unkonventionelle Anforderungen an den
Server hat, nutzen die meisten Funktionen von Lift nichts. Lift wurde in der Vergangenheit schnell
in verschiedenste Richtungen weiterentwicklet, dabei ist die Dokumentation jedoch stets
vernachlässigt worden.


  \item Das \textit{Play Framework} (Siehe auch Abschnitt \ref{sec:play}) ist dagegen bewusst
Leichtgewichtig gehalten und eher auf hohe Performance ausgelegt, als auf die Lösung möglichst
vieler Anwendungsfälle in verschiedenster ausgefallener Weise. Darüber hinaus wird Play mittlerweile
kommerziell von Typesafe unterstützt und weiterentwickelt und verfügt über eine detaillierte und
professionell gestaltete Dokumentation. \cite{play}

\end{itemize}

Erfahrungen aus früheren Projekten mit Lift scheinen an dieser Stelle nicht zu nützen, da die größte
Hürde die Implementierung der WebSocket Schnittstelle bildet und diese in Lift nur sehr spärlich
Dokumentiert sind, und zudem auch kein eindeutiger Weg zu existieren scheint.

\subsection{Authentifizierung}

Die Authentifizierung soll in diesem Projekt bewusst einfach gehalten werden, da es sich hierbei um
eine Nebensächlichkeit handelt, welche ohne weitere Probleme aufgerüstet werden kann. Wir
beschränken uns daher auf die Möglichkeit sich mit einem Benutzernamen sowie einem dazugehörigen
Passwort einzuloggen, welche dann mit einer Konfigurationsdatei auf dem Server abgeglichen wird. Wir
können dann auf die Möglichkeit des Play Frameworks zur sicheren Verwaltung von Session-Bezogenen
Daten zurückgreifen um die Anmeldung aufrechtzuerhalten.

Es ist zu erwarten, dass in einer zukünfitigen Version von Play ein eigenes Konzept zur
Authentifizierung eingeführt wird, welches dann als Ersatz für die momentane Implementierung
verwendet werden kann.

\subsection{Persistenz}

Als Besonderheit bei der Datenpersistenz sind die serverseitig zu verwaltenden Theorien zu nennen.
Da jeder Benutzer eine von allen anderen Benutzern unabhängige Menge von Projekten mit Theorien
besitzt, also eine hierarchische Struktur besteht, spricht nichts dagegen, die Daten Serverseitig im
Dateisystem zu verwalten. Somit ist auch eine eventuelle spätere Integration eines
Versionsverwaltungssystems wie \textit{Mercurial} oder \textit{Git} möglich. Da über diese Daten
hinaus nur wenige Informationen (Passwörter und Projektkonfigurationen) vom Server verwaltet werden
müssen, ist die Einrichtung und Anbindung einer Datenbank nicht von Nöten.

\subsection{Bereitstellung von Resourcen}

Das Play-Framework bietet ausgefeilte Möglichkeiten sowohl statische als aus dynamische Resourcen
bereit zu stellen. Ein Hauptaugenmerk liegt hierbei auf der Bereitstellung der nötigen \acr{js}-,
\acr{css}- sowie \acr{html}-Dateien.

Während der Entwicklung dieser Arbeit wurde ein Modul für das Play Framework entwickelt, um \textbf
{CoffeeScript-Dateien} automatisch zu \acr{js} zu übersetzen, Abhängigkeiten mit RequireJS
aufzulösen und eine Optimierte \acr{js}-Datei bereitzustellen. Da in der in Kürze erscheinenden
Version 2.1 des Play Framework ganau diese Funktionalität entwickelt wurde, liegt die Entscheidung
nahe, diese neue Funktionalität zu nutzen und das eigene Modul wegfallen zu lassen, da so eine
Weiterentwicklung bzw. die Kompatibilität mit zukünftigen Versionen des Frameworks gesichert ist.
(Siehe Abschnitt \ref{sec:coffeescript} sowie \ref{sec:requirejs})

Ebenfalls von Play unterstützt wird die Möglichkeit  \textbf{\acr{less}-Dateien} mit ihren
Abhängigkeiten zu einer \acr{css}-Datei zu übersetzen. Da diese genau wie bei der CoffeeScript-
Übersetzung zur Entwicklungszeit in lesbare und im Produktiveinsatz in optimmierte Dateien übersetzt
werden. Da die Oberfläche im Fall der Entwicklungsumgebung sehr vielschichtig und komplex ist, ist
eine Modularisierung der Stilvorlagen eine willkommene Erleichterung und im Sinne der Wartbarkeit.

\textbf{Statische Resourcen} wie in unserem Fall z.B. Font-Dateien oder fremde \acr{js}-Bibliotheken
werden durch einen sogenannten \textit{Asset}-Controler aus dem Play-Framework bereitgestellt.
Dieser bietet die Möglichkeit alle Dateien in einem Ordner statisch bereitzustellen. In unserem Fall
sind das die Dateien im Ordner \texttt{"/public"} welche unter der \acr{url} \texttt{"/assets"}
bereitgestellt werden.

Die Bereitstellung der einzelnen Dokumente bzw. Theorien findet direkt über die WebSocket API statt.
(Siehe auch Abschnitt \ref{sec:comm})

\subsection{Isabelle/Scala Integration}

Zunächst ist es für die Arbeit mit Isabelle/Scala wichtig, die 

\TODO{Isabelle/Scala auf dem Server}
