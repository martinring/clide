\chapter{Anforderungen und Entwurf}

Auf Grund der Komplexität und dem unvermeidbaren Rechenaufwand, welcher ein Theorembeweiser
mitbringt, ist es aus aktueller Sicht nahezu ausgeschlossen diese Arbeit zu größeren Teilen im
Browser zu verwirklichen. Die einzige von allen größeren Browsern unterstützte Scriptsprache ist zur
Zeit immernoch \acr{js}, welche vor allem auf Grund der dynamischen Typisierung und der
fehlenden Paralellisierbarkeit um einige Faktoren langsamer ausgeführt wird, als nativer Code.

Ein besonderer Vorteil, den die Anwendung gegenüber bisherigen Lösungen bringen soll, ist die
Mobilität. Das bedeutet, dass es von jedem Rechner mit Internetzugang und einem modernen Webbrowser
aus möglich sein soll, die Anwendung zu nutzen und auf eventuell bereits zu einem früheren Zeitpunk
an einem anderen Ort erstellten Theorien zugreifen zu können. Damit wird klar, dass die Projekte und
Theorien nicht lokal auf den einzelnen Rechnern verwaltet werden können, sondern an einer zentralen
von überall erreichbaren Stelle gespeichert sein müssen. Die Entscheidung zu einem Client-Server
Modell ergibt sich bei einer Webanwendung ohnehin automatisch.

Da es sich bei der Webanwendung um eine Entwicklungsumgebung handelt, welche insbesondere durch
Echtzeitinformationen einen Mehrwert bringen soll, ist einer der wichtigsten Aspekte des Entwurfs
die effiziente Kommunikation zwischen Server und Browser. Da die Kommunikation bei einer
Webanwendung generell sehr Zeitaufwändig ist - abhängig von der Internetanbindung kann es zu großen
Verzögerungen kommen - muss abgewogen werden, welche Arbeit im Browser und welche auf dem Server
erledigt werden soll. Als illustratives Beispiel kann das Syntax-Highlighting genannt werden:
Isabelle verfügt über eine innere und eine äußere Syntax, die sich im analytischen Aufwand stark
unterscheiden. Während die äußere Syntax relativ leicht zu parsieren ist und dabei bereits viele
Informationen liefert, ist die innere Syntax sehr komplex, flexibel und stark vom jeweiligen Kontext
abhängig. Somit liegt es nahe, das Syntaxhighlighting aufzuteilen: Um Übertragungskapazität zu
sparen kann das Highlighting der äußeren Syntax bereits im Browser mittels \acr{js} stattfinden. Die
feiner granulierten Informationen aus der inneren Syntax können dann auf dem Server ermittelt werden
und mit kurzer Verzögerung in die Darstellung integriert werden.

\section{Server}

Der Webserver muss neben den normalen Aufgaben eines Webservers, wie der Bereitstellung der Inhalte,
der Authentifizierung der Benutzer sowie der Persitierung bzw. Bereitstellung der Nutzerspezifischen
Daten (In unserem Fall Sitzungen / Theorien), auch eine besondere Schnittstelle für die Arbeit mit
den Theorien bereitstellen. Vom Browser aus muss es möglich sein, 

\begin{itemize}
  \item die einzelnen Theorien in Echtzeit zu bearbeiten,
  \item Informationen über Beweiszustände bzw. Fehler zu erhalten,
  \item als auch Informationen über die Typen, bzw. Definitionen von Ausdrücken zu erhalten.
\end{itemize}

All diese Informationen müssen zuvor Serverseitig aufbereitet und bereitgestellt werden. Dabei ist
es aus Sicht der Perfomanz wichtig, unnötige Informationen zu eliminieren und die Daten zu
komprimieren.

\subsection{Wahl des Webframeworks}

Für die Realisierung des Webservers wählen wir das \textit{Play
Framework}\footnote{http://www.playframework.org} in Version 2.1. Da wir die Isabelle/Scala
Schnittstelle nutzen, liegt es nahe ein Webframework in Scala zu nutzen um den Aufwand für die
Integration gering zu halten. Als Alternative existiert das \textit{Lift
Webframework}\footnote{http://www.liftweb.org} welches allerdings auf Grund des Rückzugs von David
Pollack aus der Entwicklung seit einiger Zeit nicht mehr geordnet weiter entwickelt wird und zudem
für unsere Zwecke überdimensioniert ist. Da die Webanwendung eher unkonventionelle Anforderungen an
den Server hat, nutzen die meisten Funktionen von \textit{Lift} nichts. Das \textit{Play}
Webframework ist hingegen vorallem auf hohe Performance und weniger auf die Lösung möglichst vieler
Anwendungsfälle ausgelegt, womit es für unsere Zwecke interessanter bleibt.

\subsection{Authentifizierung}

Die Authentifizierung soll in diesem Projekt bewusst einfach gehalten werden, da es sich hierbei um
eine Nebensächlichkeit handelt, welche ohne weitere Probleme aufgerüstet werden kann. Wir
beschränken uns daher auf die Möglichkeit sich mit einem Benutzernamen sowie einem dazugehörigen
Passwort einzuloggen, welche dann mit einer Konfigurationsdatei auf dem Server abgeglichen wird. Wir
können dann auf die Möglichkeit des Play Frameworks zur sicheren Verwaltung von Session-Bezogenen
Daten zurückgreifen um die Anmeldung aufrechtzuerhalten.

\subsection{Persistenz}

Als Besonderheit bei der Datenpersistenz sind die serverseitig zu verwaltenden Theorien zu nennen.
Da jeder Benutzer eine von allen anderen Benutzern unabhängige Menge von Projekten mit Theorien
besitzt, also eine hierarchische Struktur besteht, spricht nichts dagegen, die Daten Serverseitig im
Dateisystem zu verwalten. Somit ist auch eine eventuelle spätere Integration eines
Versionsverwaltungssystems möglich. Da über diese Daten hinaus nur wenige Informationen vom Server
verwaltet werden müssen, ist die Einrichtung und Anbindung einer Datenbank nicht von Nöten.

\subsection{Isabelle/Scala Integration}



\section{Kommunikation}

Da viele Daten in hoher Frequenz übertragen werden müssen, (Nach jeder Veränderung des Dokuments
muss der Server informiert werden, der dann zu unbestimmten Zeitpunkten in mehreren Schritten die
Zustands- Informationen zurücksendet) ist eine normale Datenübertagung wie bei Webapplikationen
üblich über \acr{ajax} bzw. \acr{http}-Anfragen nicht gut geeignet: Bei normalem \acr{http} ist es
zum einen immer nötig auf Browser Seite eine Anfrage zu stellen um Informationen vom Server zu
erhalten, zum anderen hat jede Anfrage und jede Antwort zusätzlich einen Header, welcher mindestens
einige hundert Bytes groß ist. 

Als Worst-Case Beispiel kann das Entfernen von Kommandos aus dem Dokumenten-Modell betrachtet
werden: Um das Modell eines Dokuments auf Server und Client synchron zu halten müssen ab und zu
Nachrichten vom Server gesendet werden, welche signalisieren, dass ein Kommando aus dem Modell
entfernt wurde. Diese Nachricht enthält als Information die eindeutige ID des Kommandos. Bei der ID
handelt es sich um eine 64-Bit Zahl. Zusätzlich dazu muss signalisiert werden, um welche Aktion es
sich eigentlich handelt. Dafür reichen bei der überschaubaren Anzahl an möglichen Aktionen weitere 4
Byte mehr als aus. Das bedeutet, die eigentlichen Informationen die für diese Aktion relevant sind
belaufen sich auf höchstens 12 Byte. Würde diese Aktion über \acr{http} laufen müsste zunächst eine
Anfrage gestellt werden

\begin{lstlisting}
GET /user/project/file.thy/remove-command HTTP/1.1
Host: www.clide.net
\end{lstlisting}

Diese Anfrage allein ist bereits 70 Zeichen lang ohne dass überhaupt relevante Informationen
übertragen wurden. Die minimale Antwort sähe dann in etwa so aus:

\begin{lstlisting}
HTTP/1.1 200 OK
Server: Apache/1.3.29 (Unix) PHP/4.3.4
Content-Length: 12
Content-Language: de
Connection: close
Content-Type: text/html

178
\end{lstlisting}

Das sind zusammen über 250 Zeichen um zu signalisieren, dass Kommando 178 entfernt werden soll.
Damit wurde die Information um den Faktor 30 aufgeblasen. Zusätzlich kommt es zu Verzögerungen durch
die zusätzlichen Anfragen. 

\subsection{WebSockets}
\label{sec:ws}

Die im \acr{html}5-Standard eingeführten WebSockets sind die ideale Lösung für dieses Problem. Bei
WebSockets wird eine vollduplex Verbindung über TCP aufgebaut, welche ohne den HTTP-Overhead
auskommt und lediglich ein Byte pro Nachricht benötigt um zu signalisiern, dass eine Nachricht
endet. Außerdem ist es durch die duplex Verbindung möglich sogenannte Server-Pushes wie in dem
vorangegangenen Beispiel ohne vorheriges Polling bzw. eine verzögerte Antwort auf eine Anfrage zu
realisieren.

Dadurch, dass WebSockets ein relativ neues Konzept bilden, werden durch deren Anwendung die meisten
älteren Browser von der Benutzung der Webapplikation ausgeschlossen. Ein Fallback auf HTTP wäre zwar
relativ leicht zu implementieren, aber in der Benutzung kaum akzeptabel, da sich die zusätzlichen
Verzögerungen bei teilweise weit über 1000 Nachrichten pro Minute so negativ auf die
Ausführungsgeschwindigkeit auswirken würden, dass ein produktives Arbeiten mit dem System nicht mehr
möglich wäre. Aktuell werden WebSockets von WebKit-Basierten Browsern (Google Chrome, Safari) sowie
dem Internet Explorer in der jeweils aktuellsten Version unterstützt. Mozilla Firefox erwartet einen
nicht Standard-Konformen Aufruf über \texttt{MozWebsocket} statt \texttt{WebSocket}. Da WebSockets
allerdings so unabdingbar sind wird auf die Kompatibilität mit älteren Browsern verzichtet. (Siehe
\ref{sec:comp})

\subsection{Protokoll}

Für das Protokoll wurde zunächst der Einfachheit halber \acr{json} gewählt mit der Möglichkeit im
Hinterkopf, es zu einem späteren Zeitpunkt leicht duch das komprimierte \acr{bson}-Protokoll zu
ersetzen. Um das möglich zu machen wird von WebSockets abstrahiert, (Siehe \ref{sec:jsc}) damit das
Protokoll ausgetauscht werden kann.

\section{Client}

\subsection{Browserkompatibilität}
\label{sec:comp}

Auf Grund der in \ref{sec:ws} beschriebenen Notwendigkeit, kann auf WebSockets nicht verzichtet
werden. Damit sind die meisten älteren Browser nicht mit der Anwendung kompatibel. 

\begin{table}
\centering
\caption{Kompatibilität der gängigsten Browser mit den Verwendeten Standards}
\begin{tabular}{rlllll}
                  & \textbf{Chrome} & \textbf{Safari} & \textbf{IE} & \textbf{Firefox} & \textbf{Opera} \\\hline
  WebSockets      & 14.0            & 6.0             & 10.0        & 11.0             & 12.1  \\
  History API     & 5.0             & 5.0             & 10.0        & 4.0              & 11.5  \\
  WebSockets      & 4.0             & 4.0             & 10.0        & 3.5              & 10.6  \\
  CSS Transitions & 4.0             & 3.1             & 10.0        & 4.0              & 10.5  \\
\end{tabular}
\label{tab:comp}
\end{table}

Aus Tabelle \ref{tab:comp} ist zu entnehmen, dass alle weiteren in der Anwendung benutzten Standards
eine geringere oder die gleicher Anforderung an die Aktualität des Browsers haben. Da WebSockets ein
sehr neues Konzept sind, welches notwendig ist dienen sie als Orientierung: Alle Features, welche
von jedem Browser, der WebSockets unterstützt, auch unterstützt werden, dürfen verwendet werden.
Alle anderen schließen wir aus, da sonst die Zahl der potentiellen Nutzer weiter eingeschränkt
würde. Die Anwendung sollte damit im Standardbrowser auf allen Systemen mit einem aktuellen
Betriebssystem (Windows 8, Ubuntu 12.10, OpenSUSE 12.2, OS X 10.8.2), sowie auf dem iPad, und
aktuellen Windows RT Tablets benutzbar. Bei der Entwicklung wurde jedoch besonderes Augenmerk auf
WebKit-basierte Browser, insbesondere Google Chrome gelegt und einige der anderen genannten Systeme
sind ungetestet und damit ohne Gewähr.

\subsection{Benutzeroberfläche}



\subsubsection{Die Editor-Komponente}

Die wichtigste Benutzerkomponente einer Entwicklungsumgebung ist der Text-Editor. Ein Editor für
Isabelle-Code hat hierbei besondere Anforderungen: Während in der Praxis bislang nur rudimentäre
Unterstützung für die Darstellung von Isabelle-Sonderzeichen und insbesondere von Sub und
Superskript existierte, hat Isabelle/jEdit bereits eine stärkere Integration dieser eigentlich recht
essentiellen Visualisierungen eingeführt. Da bei der \acr{html}-Darstellung kaum Grenzen gesetzt
sind und sich \acr{css}-Formatierung sehr leicht dazu benutzen lässt bestimmte Text-Inhalte
besonders darzustellen, ist es klar, dass unsere Entwicklungsumgebung an dieser Stelle besonders
glänzen soll.

In einem ersten Prototypen war es möglich eine \acr{js}-Komponente zu entwickeln, welche es zuließ,
Isabelle-Code zu bearbeiten, sodass Sub- und Superskript sowie

\subsection{Client-Modell}

\subsection{}