\section{Scala}

Die Programmiersprache Scala ist eine an der École polytechnique fédérale de  Lausanne von einem
Team um Martin Odersky entwickelte statisch typisiserte,  objektorientierte, funktionale
Sprache\cite{scala}. In Scala entwickelte Programme laufen  sowohl in der \textit{Java Virtual
Machine} (JVM) als auch in der \textit{Common  Language Runtime} (CLR). Die Implementierung für die
CLR hängt jedoch stark  hinterher und ist für diese Arbeit auch nicht von Interesse. Die aktuelle
Sprachversion ist Scala 2.10 welche auch im Rahmen dieser Arbeit verwendet wird.

Scala versucht von Anfang an den Spagat zwischen funktionaler und  objektorientierter Programmierung
herzustellen. Hierbei ist es sowohl möglich  rein objektorientierten als auch rein funktionalen Code
zu schreiben. Dadurch  entstehen für den Programmierer sehr große Freiheitsgrade und es ist
beispielsweise auch möglich imperativen und funktionalen Code zu mischen. Diese  Freiheit erfordert
eine gewisse Verantwortung von Seiten des Programmierers um  lesbaren und wartbaren Code zu
erstellen.

\subsection{Sprachkonzepte}

\subsubsection{Implizite Parameter}

Implizite Parameter werden in Scala verwendet um Parameter die sich aus dem  Kontext eines
Funktionsaufrufs erschließen können nicht explizit übergeben zu  müssen. Eine Funktion \texttt{f}
besitzt hierbei zusätzlich zu den normalen  Parameterlisten auch eine implizite Parameterliste:

\begin{lstlisting}
f(a: Int)(implicit x: T1, y: T2)
\end{lstlisting}

In dem Beispiel hat die Funktion einen normalen Parameter \texttt{a} und zwei  implizite Parameter
\texttt{x} und \texttt{y}. Der Compiler sucht bei einem  Funktionsaufruf, welcher die beiden oder
einen der impliziten Parameter nicht  spezifiziert nach impliziten Definitionen vom Typ \texttt{T1}
bzw. \texttt{T2}.  Diese Definitionen werden im aktuell sichtbaren Scope nach bestimmten
Prioritäten gesucht. Dabei wird zunächst im aktuellen Objekt, dann im zu den  typen \texttt{T1} und
\texttt{T2} gehörenden objekten und dann in den  importierten Namensräumen gesucht. Implizite
definitionen haben die Form  \texttt{implicit def/val/var x: T = ...} wobei der name \texttt{x}
keine Rolle  spielt.

\subsubsection{Implizite Konversionen}

In Scala existiert das Konzept der impliziten Konversionen. Hierbei werden bei  Typfehlern zur
Kompilierzeit Funktionen mit dem Modifizierer \texttt{implicit}  gesucht, die den gefundenen Typen
in den nötigen Typen umwandeln können gesucht.  Die Priorisierung ist genauso wie bei impliziten
Parametern. Ein Beispiel:

\begin{lstlisting}
implicit def t1tot2(x: T1): T2 = ...
def f(x: T2) = ...

val x: T1 = ...
f(x)
\end{lstlisting}

In dem Beispiel wird eine implizite konversion von \texttt{T1} nach \texttt{T2}  definiert. Bei dem
Aufruf \texttt{f(x)} kommt es zu einem Typfehler, weil  \texttt{T2} erwartet und \texttt{T1}
übergeben wird. Dieser Typfehler wird  gelöst indem vom Compiler die implizite Konversion eingesetzt
wird. Der Aufruf  wird also intern erweitert zu \texttt{f(t1tot2(x))}.

\subsubsection{Typklassen}

Mit Hilfe von impliziten Definitionen ist es möglich das aus der Sprache Haskell  bekannte Konzept
der Typklassen in Scala nachzubilden.

Eine Typklasse bietet die möglichkeit Ad-hoc-Polymorphie zu implementieren.  Damit ist es möglich
ähnlich wie bei Schnittstellen Funktionen für eine ganze  Menge von Typen bereitzustellen. Diese
müssen jedoch nicht direkt von den Typen  implementiert sein und können auch Nachträglich
beispielsweise für Typen aus  fremden Bibliotheken definiert werden.

In Scala werden Typklassen als generische abstrakte Klassen oder Traits  implementiert.

Instanzen der Typklassen sind implizite Objektdefinitionen welche für einen  spezifischen Typen die
Typklasse bzw. die abstrakte Klasse implementieren.

Eine Funktion für eine bestimmte Typklasse kann durch eine generische Funktion  realisiert werden.
Diese ist dann über einen oder mehrere Typen parametrisiert  und erwartet als implizites Argument
eine Instanz der Typklasse für diese Typen,  also eine implizite Objektdefinition. Wenn diese im
Namensraum existiert, wird  sie automatisch vom Compiler eingesetzt.

Dieses Konzept ist vor allem sehr Hilfreich wenn es darum geht fremde  Bibliotheken zu erweitern.

\subsubsection{Dynamische Typisierung}

Seit Scala 2.10 ist es möglich Funktionsaufrufe bei Typfehlern Dynamisch zur  Laufzeit auflösen zu
lassen. Damit die Typsicherheit nicht generell verloren  geht ist es nötig den Trait
\texttt{Dynamic} zu importieren um einen Typ als  Dynamisch zu deklarieren. Wenn die Typüberprüfung
dann bei einem Aufruf  fehlschlägt wird der Aufruf auf eine der Funktionen \texttt{applyDynamic},
\texttt{applyDynamicNamed}, \texttt{selectDynamic} und \texttt{updateDynamic}  abgebildet:

\begin{lstlisting}
x.method("arg")    =>  x.applyDynamic("method")("arg")
x.method(x = y)    =>  x.applyDynamicNamed("method")(("x", y))
x.method(x = 1, 2) =>  x.applyDynamicNamed("method")(("x", 1), ("", 2))
x.field            =>  x.selectDynamic("field")
x.variable = 10    =>  x.updateDynamic("variable")(10)
x.list(10) = 13    =>  x.selectDynamic("list").update(10, 13)
x.list(10)         =>  x.applyDynamic("list")(10)
\end{lstlisting}
 
\subsection{Akka}

\cite{actors}

\texttt{Akka} ist eine Implementierung des Aktoren-Modells.

\subsection{Play Framework}

Das \textit{Play Framework} ist ein Framework zur Entwicklung von Webanwendungen  auf der JVM mit
einer speziellen API für Scala. Play ist ein sehr effizientes  Framework welches auf Akka aufbaut um
hohe Skalierbarkeit zu gewährleisten.  Damit wird es leichter verteilte hochperformante
Webanwendungen zu realisieren.

\subsubsection{LESS}

Play ermöglicht es die Stylesheet-Sprache \textit{LESS} zu verwenden ohne,  dass diese auf
Browserseite unterstützt werden muss. Hierfür werden die in  \textit{LESS} definierten Stylesheet
auf Serverseite in \textit{CSS} übersetzt  und dem Browser zur Verfügung gestellt.

Dafür müssen die Dateien an einem vorher konfigurierten Ort liegen. Nach dem  übersetzen werden sie
an der selben Stelle zur Verfügung gestellt wie normale  \textit{CSS} Dateien.

\subsubsection{CoffeeScript}

Genauso wie für \textit{LESS} existiert in Play die Serverseitige Unterstützung  für
\textit{CoffeeScript}. Die in \textit{CoffeeScript} geschriebenen Dateien  werden ebenfalls an
gleicher Stelle wie normale \textit{JavaScript}-Dateien dem  Browser als \textit{JavaScript} zur
Verfügung gestellt.

\subsubsection{RequireJS}

Die \textit{RequireJS} Bibliothek bietet die Möglichkeit den  \textit{JavaScript}-Code für den
Produktiveinsatz zu optimieren. Dafür gibt es  das sogenannte \textit{r.js}-Script welches unter
andem alle Abhängigkeiten  zusammenfasst und den Code durch das Entfernen von Whitespaces und
Kommentaren  sowie dem Umbenennen von Variablennamen verkürzt. Zur Entwicklungszeit ist diese  nicht
mehr lesbare Code nicht erwünscht. Deswegen bietet Play eine integrierte  Version von RequireJS,
welche automatisch den lesbaren Code zur Entwicklungszeit  bereitstellt, im Produktiveisatz jedoch
den optimierten.

\subsubsection{Iteratees}

\subsubsection{Websockets}

Websockets werden direkt von Play unterstützt. ...